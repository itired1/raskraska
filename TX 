import pygame
import sys
import numpy as np
import json
import os
import random
from pygame import gfxdraw

# Инициализация Pygame
pygame.init()

# Константы
SCREEN_WIDTH = 1100
SCREEN_HEIGHT = 850
SAVE_FILE = "paint_save.json"

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (200, 200, 200)
LIGHT_GRAY = (230, 230, 230)
PANEL_COLOR = (240, 240, 245)
BUTTON_COLOR = (70, 130, 180)
BUTTON_HOVER = (100, 150, 200)
PANEL_BORDER = (180, 180, 180)
PROGRESS_BAR_COLOR = (100, 200, 100)
PROGRESS_BG_COLOR = (220, 220, 220)
HOVER_COLOR = (220, 220, 220, 150)
COMPLETION_ANIMATION_COLOR = (50, 200, 50)
GRID_HIGHLIGHT_COLOR = (255, 255, 0, 100)

COLOR_PALETTE = {
    1: (255, 0, 0),      # Красный
    2: (0, 0, 255),      # Синий
    3: (0, 255, 0),      # Зелёный
    4: (255, 255, 0),    # Жёлтый
    5: (255, 165, 0),    # Оранжевый
    6: (128, 0, 128),    # Фиолетовый
    7: (0, 255, 255),    # Голубой
    8: (255, 192, 203),  # Розовый
    9: (165, 42, 42),    # Коричневый
    10: (0, 0, 0),       # Чёрный
}

# Уровни
LEVELS = [
    {  # Уровень 1: Сердце (5x5)
        "name": "Сердце",
        "grid": [
            [0, 1, 0, 1, 0],
            [1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1],
            [0, 1, 1, 1, 0],
            [0, 0, 1, 0, 0],
        ],
        "cell_size": 80,
        "difficulty": "Легкий"
    },
    {  # Уровень 2: Дом (8x8)
        "name": "Дом",
        "grid": [
            [0, 0, 0, 1, 1, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 0],
            [1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 2, 2, 2, 2, 1, 1],
            [1, 1, 2, 2, 2, 2, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1],
        ],
        "cell_size": 60,
        "difficulty": "Средний"
    },
    {  # Уровень 3: Машина (10x10)
        "name": "Машина",
        "grid": [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [1, 1, 3, 3, 1, 1, 3, 3, 1, 1],
            [1, 1, 3, 3, 1, 1, 3, 3, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
        ],
        "cell_size": 50,
        "difficulty": "Средний"
    }
]

class PaintByNumbers:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Рисование по номерам")
        self.clock = pygame.time.Clock()
        self.current_level = 0
        self.selected_color = 1
        self.math_problem = ""
        self.math_answer = None
        self.math_input = ""
        self.math_feedback = ""
        self.math_feedback_timer = 0
        self.show_math_panel = False
        self.font_large = pygame.font.SysFont("Arial", 36)
        self.font_medium = pygame.font.SysFont("Arial", 28)
        self.font_small = pygame.font.SysFont("Arial", 20)
        self.progress = 0
        self.target_progress = 0
        self.color_unlocked = False
        self.active_input = False
        self.completion_animation = False
        self.completion_alpha = 0
        self.hovered_cell = None
        self.last_hover_time = 0
        self.progress_animation = 0
        
        self.load_level(self.current_level)
        self.load_progress()

    def safe_load_json(self, filepath):
        try:
            if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                with open(filepath, 'r') as f:
                    return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Ошибка загрузки файла {filepath}: {e}")
        return {}

    def load_level(self, level_idx):
        if 0 <= level_idx < len(LEVELS):
            self.current_level = level_idx
            level = LEVELS[level_idx]
            self.grid = np.array(level["grid"])
            self.colored = np.zeros_like(self.grid)
            self.cell_size = level["cell_size"]
            self.level_name = level["name"]
            self.difficulty = level["difficulty"]
            self.total_cells = np.count_nonzero(self.grid)
            self.update_progress(instant=True)
            self.completion_animation = False
            self.completion_alpha = 0

    def update_progress(self, instant=False):
        colored_cells = np.count_nonzero(self.colored)
        self.target_progress = int((colored_cells / self.total_cells) * 100) if self.total_cells > 0 else 0
        
        if instant:
            self.progress = self.target_progress
            self.progress_animation = self.target_progress
        elif self.target_progress == 100:
            self.completion_animation = True
            self.save_progress()

    def load_progress(self):
        data = self.safe_load_json(SAVE_FILE)
        if str(self.current_level) in data:
            try:
                saved_data = np.array(data[str(self.current_level)])
                if saved_data.shape == self.grid.shape:
                    self.colored = saved_data
                    self.update_progress(instant=True)
            except Exception as e:
                print(f"Ошибка загрузки прогресса: {e}")

    def save_progress(self):
        try:
            data = {}
            if os.path.exists(SAVE_FILE):
                data = self.safe_load_json(SAVE_FILE)
            
            data[str(self.current_level)] = self.colored.tolist()
            
            with open(SAVE_FILE, 'w') as f:
                json.dump(data, f, indent=4)
        except Exception as e:
            print(f"Ошибка сохранения прогресса: {e}")

    def generate_math_problem(self, color_num):
        operations = ['+', '-', '*']
        op = random.choice(operations)
        
        if op == '+':
            a = random.randint(1, 15)
            b = random.randint(1, 15)
            answer = a + b
        elif op == '-':
            a = random.randint(5, 20)
            b = random.randint(1, a)
            answer = a - b
        else:  # '*'
            a = random.randint(1, 9)
            b = random.randint(1, 9)
            answer = a * b
        
        self.math_problem = f"{a} {op} {b} = ?"
        self.math_answer = answer
        self.math_input = ""
        self.show_math_panel = True
        self.selected_color = color_num
        self.color_unlocked = False
        self.active_input = True

    def check_math_answer(self):
        try:
            user_answer = int(self.math_input)
            if user_answer == self.math_answer:
                self.math_feedback = "Правильно! Цвет разблокирован."
                self.color_unlocked = True
                self.math_feedback_timer = 120
            else:
                self.math_feedback = f"Ошибка! Правильно: {self.math_answer}"
                self.math_feedback_timer = 120
        except ValueError:
            self.math_feedback = "Введите число!"
            self.math_feedback_timer = 120

    def draw_color_palette(self):
        palette_x = 20
        palette_y = 150
        color_size = 50
        margin = 10
        cols = 5
        
        palette_rect = pygame.Rect(palette_x - 5, palette_y - 35, 
                                 cols * (color_size + margin) + 10, 
                                 min(3, (len(COLOR_PALETTE)+cols-1)//cols * (color_size + margin) + 40)
        pygame.draw.rect(self.screen, PANEL_COLOR, palette_rect, border_radius=10)
        pygame.draw.rect(self.screen, PANEL_BORDER, palette_rect, 2, border_radius=10)
        
        title = self.font_medium.render("Палитра цветов:", True, BLACK)
        title_rect = title.get_rect(center=(palette_x + (cols*(color_size + margin))//2, palette_y - 20))
        self.screen.blit(title, title_rect)
        
        for i, (color_num, color) in enumerate(COLOR_PALETTE.items()):
            row = i // cols
            col = i % cols
            
            x = palette_x + col * (color_size + margin)
            y = palette_y + row * (color_size + margin)
            
            rect = pygame.Rect(x, y, color_size, color_size)
            
            mouse_pos = pygame.mouse.get_pos()
            hover = rect.collidepoint(mouse_pos)
            
            if hover:
                hover_surface = pygame.Surface((color_size, color_size), pygame.SRCALPHA)
                hover_surface.fill(HOVER_COLOR)
                self.screen.blit(hover_surface, rect)
                
                if pygame.mouse.get_pressed()[0]:
                    self.generate_math_problem(color_num)
            
            pygame.draw.rect(self.screen, color, rect, border_radius=5)
            
            if color_num == self.selected_color:
                if self.color_unlocked:
                    pygame.draw.rect(self.screen, (0, 255, 0), rect, 3, border_radius=5)
                else:
                    pygame.draw.rect(self.screen, (255, 0, 0), rect, 3, border_radius=5)
            else:
                pygame.draw.rect(self.screen, BLACK, rect, 1, border_radius=5)
            
            num_text = self.font_small.render(str(color_num), True, BLACK)
            num_rect = num_text.get_rect(center=rect.center)
            self.screen.blit(num_text, num_rect)

    def draw_math_panel(self):
        if not self.show_math_panel:
            return
            
        panel_rect = pygame.Rect(SCREEN_WIDTH//2 - 250, SCREEN_HEIGHT//2 - 150, 500, 300)
        pygame.draw.rect(self.screen, PANEL_COLOR, panel_rect, border_radius=15)
        pygame.draw.rect(self.screen, PANEL_BORDER, panel_rect, 3, border_radius=15)
        
        title = self.font_large.render(f"Решите задачу для цвета {self.selected_color}", True, BLACK)
        title_rect = title.get_rect(center=(panel_rect.centerx, panel_rect.y + 50))
        self.screen.blit(title, title_rect)
        
        problem_text = self.font_large.render(self.math_problem, True, (0, 0, 150))
        problem_rect = problem_text.get_rect(center=(panel_rect.centerx, panel_rect.y + 100))
        self.screen.blit(problem_text, problem_rect)
        
        input_rect = pygame.Rect(panel_rect.centerx - 100, panel_rect.y + 150, 200, 50)
        pygame.draw.rect(self.screen, WHITE, input_rect, border_radius=5)
        border_color = BUTTON_HOVER if self.active_input else PANEL_BORDER
        pygame.draw.rect(self.screen, border_color, input_rect, 3, border_radius=5)
        
        input_text = self.font_large.render(self.math_input, True, BLACK)
        input_text_rect = input_text.get_rect(center=input_rect.center)
        self.screen.blit(input_text, input_text_rect)
        
        check_rect = pygame.Rect(panel_rect.centerx - 100, panel_rect.y + 220, 200, 50)
        pygame.draw.rect(self.screen, BUTTON_COLOR, check_rect, border_radius=5)
        
        if check_rect.collidepoint(pygame.mouse.get_pos()):
            hover_surface = pygame.Surface((200, 50), pygame.SRCALPHA)
            hover_surface.fill((*BUTTON_HOVER, 50))
            self.screen.blit(hover_surface, check_rect)
        
        check_text = self.font_medium.render("Проверить", True, WHITE)
        check_text_rect = check_text.get_rect(center=check_rect.center)
        self.screen.blit(check_text, check_text_rect)
        
        if self.math_feedback_timer > 0:
            color = (0, 180, 0) if "Правильно" in self.math_feedback else (180, 0, 0)
            feedback_text = self.font_medium.render(self.math_feedback, True, color)
            feedback_rect = feedback_text.get_rect(center=(panel_rect.centerx, panel_rect.y + 270))
            self.screen.blit(feedback_text, feedback_rect)
            self.math_feedback_timer -= 1
            
            if self.math_feedback_timer == 0 and self.color_unlocked:
                self.show_math_panel = False

    def draw_grid(self):
        rows, cols = self.grid.shape
        start_x = (SCREEN_WIDTH - cols * self.cell_size) // 2
        start_y = 300
        
        mouse_pos = pygame.mouse.get_pos()
        self.hovered_cell = None
        
        for y in range(rows):
            for x in range(cols):
                rect = pygame.Rect(
                    start_x + x * self.cell_size,
                    start_y + y * self.cell_size,
                    self.cell_size,
                    self.cell_size
                )
                
                if rect.collidepoint(mouse_pos):
                    self.hovered_cell = (x, y)
                    if pygame.time.get_ticks() - self.last_hover_time > 300:
                        if self.grid[y, x] == self.selected_color:
                            hover_surface = pygame.Surface((self.cell_size, self.cell_size), pygame.SRCALPHA)
                            hover_surface.fill(GRID_HIGHLIGHT_COLOR)
                            self.screen.blit(hover_surface, rect)
                        self.last_hover_time = pygame.time.get_ticks()
                
                if self.colored[y, x] != 0:
                    pygame.draw.rect(self.screen, COLOR_PALETTE[self.colored[y, x]], rect, border_radius=3)
                elif self.grid[y, x] != 0:
                    pygame.draw.rect(self.screen, WHITE, rect, border_radius=3)
                    text = self.font_small.render(str(self.grid[y, x]), True, BLACK)
                    text_rect = text.get_rect(center=rect.center)
                    self.screen.blit(text, text_rect)
                else:
                    pygame.draw.rect(self.screen, LIGHT_GRAY, rect, border_radius=3)
                
                pygame.draw.rect(self.screen, BLACK, rect, 1, border_radius=3)
        
        if self.completion_animation:
            self.completion_alpha = min(self.completion_alpha + 4, 180)
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((*COMPLETION_ANIMATION_COLOR, self.completion_alpha))
            self.screen.blit(overlay, (0, 0))
            
            if self.completion_alpha >= 180:
                congrats_text = self.font_large.render("Уровень пройден!", True, WHITE)
                text_rect = congrats_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
                self.screen.blit(congrats_text, text_rect)
                
                if self.current_level < len(LEVELS) - 1:
                    next_btn = pygame.Rect(SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2 + 50, 200, 50)
                    pygame.draw.rect(self.screen, BUTTON_COLOR, next_btn, border_radius=5)
                    
                    if next_btn.collidepoint(pygame.mouse.get_pos()):
                        hover_surface = pygame.Surface((200, 50), pygame.SRCALPHA)
                        hover_surface.fill((*BUTTON_HOVER, 50))
                        self.screen.blit(hover_surface, next_btn)
                    
                    next_text = self.font_medium.render("Следующий уровень", True, WHITE)
                    next_text_rect = next_text.get_rect(center=next_btn.center)
                    self.screen.blit(next_text, next_text_rect)

    def draw_ui(self):
        pygame.draw.rect(self.screen, PANEL_COLOR, (0, 0, SCREEN_WIDTH, 100))
        pygame.draw.rect(self.screen, PANEL_BORDER, (0, 0, SCREEN_WIDTH, 100), 2)
        
        title = f"{self.level_name} (Ур. {self.current_level + 1}/{len(LEVELS)})"
        title_text = self.font_large.render(title, True, BLACK)
        title_rect = title_text.get_rect(midleft=(20, 30))
        if title_rect.right > SCREEN_WIDTH - 250:
            title = f"{self.level_name[:10]}... (Ур. {self.current_level + 1}/{len(LEVELS)})"
            title_text = self.font_large.render(title, True, BLACK)
            title_rect = title_text.get_rect(midleft=(20, 30))
        self.screen.blit(title_text, title_rect)
        
        difficulty_text = self.font_medium.render(f"Сложность: {self.difficulty}", True, BLACK)
        difficulty_rect = difficulty_text.get_rect(midleft=(20, 70))
        self.screen.blit(difficulty_text, difficulty_rect)
        
        prev_btn = pygame.Rect(SCREEN_WIDTH - 250, 20, 100, 40)
        next_btn = pygame.Rect(SCREEN_WIDTH - 120, 20, 100, 40)
        
        pygame.draw.rect(self.screen, BUTTON_COLOR if self.current_level > 0 else GRAY, prev_btn, border_radius=5)
        prev_text = self.font_medium.render("Назад", True, WHITE)
        prev_text_rect = prev_text.get_rect(center=prev_btn.center)
        self.screen.blit(prev_text, prev_text_rect)
        
        pygame.draw.rect(self.screen, BUTTON_COLOR if self.current_level < len(LEVELS) - 1 else GRAY, next_btn, border_radius=5)
        next_text = self.font_medium.render("Вперёд", True, WHITE)
        next_text_rect = next_text.get_rect(center=next_btn.center)
        self.screen.blit(next_text, next_text_rect)
        
        progress_width = 400
        progress_rect = pygame.Rect((SCREEN_WIDTH - progress_width) // 2, 20, progress_width, 25)
        
        if self.progress_animation < self.target_progress:
            self.progress_animation += 1
        elif self.progress_animation > self.target_progress:
            self.progress_animation -= 1
        
        pygame.draw.rect(self.screen, PROGRESS_BG_COLOR, progress_rect, border_radius=12)
        
        fill_width = int(progress_width * self.progress_animation / 100)
        fill_rect = pygame.Rect((SCREEN_WIDTH - progress_width) // 2, 20, fill_width, 25)
        pygame.draw.rect(self.screen, PROGRESS_BAR_COLOR, fill_rect, border_radius=12)
        
        pygame.draw.rect(self.screen, PANEL_BORDER, progress_rect, 2, border_radius=12)
        
        progress_text = self.font_medium.render(f"{self.progress_animation}%", True, BLACK)
        progress_text_rect = progress_text.get_rect(center=progress_rect.center)
        self.screen.blit(progress_text, progress_text_rect)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.save_progress()
                pygame.quit()
                sys.exit()
                
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    if self.hovered_cell and self.color_unlocked and not self.show_math_panel:
                        x, y = self.hovered_cell
                        if self.grid[y, x] != 0:
                            if self.selected_color == self.grid[y, x]:
                                self.colored[y, x] = self.selected_color
                                self.update_progress()
                                self.save_progress()
                            else:
                                self.math_feedback = f"Можно использовать только для клеток {self.selected_color}!"
                                self.math_feedback_timer = 120
                                self.show_math_panel = True
                    
                    prev_btn = pygame.Rect(SCREEN_WIDTH - 250, 20, 100, 40)
                    next_btn = pygame.Rect(SCREEN_WIDTH - 120, 20, 100, 40)
                    
                    if prev_btn.collidepoint(event.pos) and self.current_level > 0:
                        self.load_level(self.current_level - 1)
                    elif next_btn.collidepoint(event.pos) and self.current_level < len(LEVELS) - 1:
                        self.load_level(self.current_level + 1)
                    
                    if self.completion_animation and self.target_progress == 100:
                        next_btn = pygame.Rect(SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2 + 50, 200, 50)
                        if next_btn.collidepoint(event.pos) and self.current_level < len(LEVELS) - 1:
                            self.load_level(self.current_level + 1)
                            self.completion_animation = False
                
            elif event.type == pygame.KEYDOWN:
                if self.active_input and self